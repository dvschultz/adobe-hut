#target Illustrator// move shapes around pleasedoc = app.activeDocument;var sizeArray = [];var b = new RGBColor;b.red = 255;b.blue = 0;b.green = 0;if ( app.documents.length > 0 && app.activeDocument.pathItems.length > 0 ) {        //loop through groups, store array    for (var i = 0; i < doc.groupItems.length; i++ ) {        groupRef = doc.groupItems[i];        var groupObj = {index:i,size:groupRef.height};        sizeArray.push(groupObj);    }//~     $.writeln(sizeArray.length); //debug        //put circle packing algo here    circlePack(sizeArray);}redraw();function circlePack(circleArray) {    var sortedArray = circleArray.slice();    sortedArray.sort(compare);//~     for(var i = 0; i < sortedArray.length; i++){//~         $.writeln(sortedArray[i].size);//~     }        var count = circleArray.length,        maxRad = sortedArray[sortedArray.length-1].size/2,        minRad = sortedArray[0].size/2;        //~     $.writeln("count: " + count);//~     $.writeln("maxRad: " + maxRad);//~     $.writeln("minRad: " + minRad);    var currentCount = 0,        sameCount = 0;            var newX,newY,newR;    var xArray = [],        yArray = [],        rArray = [],        cArray = [],        indexArray = [],        closestIndex = [];            //todo: don’t assume artboard is at 0,0    var docH = Math.abs(doc.artboards[doc.artboards.getActiveArtboardIndex()].artboardRect[3]),        docW = Math.abs(doc.artboards[doc.artboards.getActiveArtboardIndex()].artboardRect[2]);        //~         $.writeln("docH: " + docH);//~         $.writeln("docW: " + docW);            while(currentCount < count) {        var countChanged = false;                  //get random position        newX = Math.random() * (docW-maxRad*2) + maxRad;        newY = Math.random() * (docH-maxRad*2) + maxRad;        newR = minRad;//~         $.writeln("newX: " + newX);//~         $.writeln("newY: " + newY);                intersection = false;                for(var i=0; i < currentCount; i++) {		    var d = dist(newX,newY, xArray[i],yArray[i]);		    if (d < (newR + rArray[i])) {		     	intersection = true; 		     	break;		    }		}                        if (intersection == false ) {			            // get closest neighbour and closest possible radius            var newRadius = docW,                cRadius = minRad;                      for(var i=0; i < currentCount; i++) {                var d = dist(newX,newY, xArray[i],yArray[i]);                if (newRadius > d-rArray[i]) {                    newRadius = d-rArray[i];                    closestIndex[currentCount] = i;                }            }            if (newRadius > maxRad) newRadius = maxRad;            var sizeChanged = false;                        //compare possible radius to array of possible circles            if(newRadius >= sortedArray[sortedArray.length-1].size/2) {                $.writeln('got it: the biggest');                cRadius = sortedArray[sortedArray.length-1].size;                sortedArray.splice(sortedArray.length-1,1);                sizeChanged= true;            } else if (newRadius <= sortedArray[0].size/2) {                $.writeln('got it: the smallest');                 cRadius = sortedArray[0].size;                sortedArray.splice(0,1);                sizeChanged= true;            } else {                //$.writeln('got it: in between');                for(var i = 0; i < sortedArray.length-1; i++){                    if((newRadius > sortedArray[i].size/2) && (newRadius < sortedArray[i+1].size/2) ) {                        $.writeln('got it: in between');                        cRadius = sortedArray[i].size;                        sortedArray.splice(i,1);                        sizeChanged= true;                        break;                    }                 }            }                    if (!sizeChanged) $.writeln("crap");                        xArray[currentCount] = newX;            yArray[currentCount] = newY;            rArray[currentCount] = newRadius;            cArray[currentCount] = cRadius;            sameCount = 0;            currentCount++;            countChanged = true;            if (sortedArray.length > 1) {                maxRad = sortedArray[sortedArray.length-1].size/2;                minRad = sortedArray[0].size/2;            }                        $.writeln(currentCount);		} // end if (intersection == false )                // escape hatch//~         if (countChanged == false) {//~ 		  	sameCount++;//~ 		  	if (sameCount > 99999) {//~                     $.writeln('uh oh');//~ 		  		sameCount = 0;//~ 		  		break;//~ 		  	}//~ 		}            } //end while(currentCount < maxCount)$.writeln(rArray.length);    for(var i = 0; i < count; i++){        var g = getCircleBySize(cArray[i]);        if(g != undefined) {            var groupRef = doc.groupItems[g];    //~         $.writeln(groupRef.height);            groupRef.left = xArray[i] - groupRef.width/2;            groupRef.top = (yArray[i] - groupRef.height/2) * -1;        }            }    } // end circlePackfunction compare(a,b) {    return a.size - b.size;}function dist(x1,y1,x2,y2) {    return Math.sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );}function getCircleBySize(size) {    var circleIndex;    for(var i = 0; i < sizeArray.length; i++) {        var c = sizeArray[i];        if (c.size == size) {            circleIndex = c.index;            break;        }    }    //$.writeln(circleIndex);    return circleIndex;}