#target illustratorvar DEBUG = false;//things you can setvar tabSize = 18;var pyramidHeight = 144; //height in points//things you can’t setvar doc, artLayer, currX, currY;var extrudes = [];//fold linevar red = new RGBColor();red.red = 255;red.green = 0;red.blue = 0;//cut linevar black = new RGBColor();black.red = 0;black.green = 0;black.blue = 0;//test linevar cyan = new RGBColor();cyan.red = 0;cyan.green = 255;cyan.blue = 255;if ( app.documents.length > 0 ) {    doc = app.activeDocument;    doc.defaultStrokeColor = red;    artLayer = doc.layers[0];    currX = currY = 0;    doIt();}function doIt() {    for (var i = 0; i < doc.pathItems.length; i++ ) {        pathRef = doc.pathItems[i];        if(!pathRef.selected && DEBUG) {            pathRef.remove();            continue;        }        if(!pathRef.selected && !DEBUG) continue;        extrudes.push(i);    }    for(var i = 0; i < extrudes.length; i++) {        pathRef = doc.pathItems[extrudes[i]];        createEqTri(pathRef);    }}function createEqTri(path) {    currX = currY = 0;    var pw,ph,pyrH,sh;    pw = Math.round(path.width);    ph = Math.round(path.height);        //todo: calc pyramid height    if(pw == ph){        sh = Math.sqrt( (pw*pw) - ((pw/2)*(pw/2)) );        pyrH = Math.sqrt( (sh*sh) - ((pw/2)*(pw/2)) );    } else {        pyrH = pyramidHeight; //two inches        sh = Math.sqrt( Math.pow(ph/2,2) + Math.pow(pyrH,2) );        sh2 = Math.sqrt( Math.pow(pw/2,2) + Math.pow(pyrH,2) );    }    //generate group    var g = doc.groupItems.add();        //draw base    drawLine(currX,currY,currX,currY-ph,{"addTo":g,"strokeColor":red});    drawLine(currX,currY-ph,currX+pw,currY-ph,{"addTo":g,"strokeColor":red});    drawLine(currX+pw,currY-ph,currX+pw,currY,{"addTo":g,"strokeColor":red});    drawLine(currX+pw,currY,currX,currY,{"addTo":g,"strokeColor":red});        //draw tabs    //left    drawLine(currX,currY,currX-tabSize,currY-tabSize,{"addTo":g,"strokeColor":black});    drawLine(currX-tabSize,currY-tabSize,currX-tabSize,currY-(ph-tabSize),{"addTo":g,"strokeColor":black});    drawLine(currX-tabSize,currY-(ph-tabSize),currX,currY-ph,{"addTo":g,"strokeColor":black});    //bottom    drawLine(currX,currY-ph,currX+tabSize,currY-ph-tabSize,{"addTo":g,"strokeColor":black});    drawLine(currX+tabSize,currY-ph-tabSize,currX+(pw-tabSize),currY-ph-tabSize,{"addTo":g,"strokeColor":black});    drawLine(currX+(pw-tabSize),currY-ph-tabSize,currX+pw,currY-ph,{"addTo":g,"strokeColor":black});    //right    drawLine(currX+pw,currY,currX+pw+tabSize,currY-tabSize,{"addTo":g,"strokeColor":black});    drawLine(currX+pw+tabSize,currY-tabSize,currX+pw+tabSize,currY-(ph-tabSize),{"addTo":g,"strokeColor":black});    drawLine(currX+pw+tabSize,currY-(ph-tabSize),currX+pw,currY-ph,{"addTo":g,"strokeColor":black});        //first and third triangles: base is pw, radius is ph/2    //slant height (sh) is sqrt of pyrH squared + radius squared//~     drawLine(currX+pw/2,currY,currX+pw/2,currY+sh,cyan); //sh    drawLine(currX,currY,currX+pw/2,currY+sh,{"addTo":g,"strokeColor":red});    drawLine(currX+pw/2,currY+sh,currX+pw,currY,{"addTo":g,"strokeColor":red});//~     drawLine(currX+pw/2,currY-ph,currX+pw/2,currY-ph-sh,cyan); //sh    // get first angle    var a1 = Math.atan( sh/(pw/2) );    var a2 = Math.atan( sh2/(ph/2) );    var shiftX = ph * Math.cos(Math.PI - (a1+a2));    var shiftY = ph * Math.sin(Math.PI - (a1+a2));       var newX = currX+pw+shiftX;    var newY = currY+shiftY;       //second triangles: base is ph, radius is pw/2    drawLine(currX+pw,currY,newX,newY,{"addTo":g,"strokeColor":black});    drawLine(newX,newY,currX+pw/2,currY+sh,{"addTo":g,"strokeColor":red});        //fourth triangle: reversed position    drawLine(currX,currY,currX-shiftX,currY+shiftY,{"addTo":g,"strokeColor":black});    drawLine(currX-shiftX,currY+shiftY,currX+pw/2,currY+sh,{"addTo":g,"strokeColor":black});        var a3 = ((Math.PI - (a1+a2))*2);    //draw third triangle on end    var shiftX = pw * Math.cos(a3);    var shiftY = pw * Math.sin(a3);        drawLine(newX,newY,newX+shiftX,newY+shiftY,{"addTo":g,"strokeColor":black});    drawLine(newX,newY,newX+shiftX,newY+shiftY,{"addTo":g,"strokeColor":black});    drawLine(newX+shiftX,newY+shiftY,currX+pw/2,currY+sh,{"addTo":g,"strokeColor":red});    var lastAngle = angleFromPoints(newX+shiftX,newY+shiftY,currX+pw/2,currY+sh);    var lastLineDist = dist(newX+shiftX,newY+shiftY,currX+pw/2,currY+sh);    var angleDist = Math.sqrt((tabSize*tabSize) + (tabSize*tabSize));        //draw tab    tabStartX = newX+shiftX;    tabStartY = newY+shiftY;    tabShiftX = angleDist * Math.cos(lastAngle-Math.PI/4);    tabShiftY = angleDist * Math.sin(lastAngle-Math.PI/4);    drawLine(tabStartX,tabStartY,tabStartX-tabShiftX,tabStartY-tabShiftY,{"addTo":g,"strokeColor":black});    tabStartX = tabStartX-tabShiftX;    tabStartY = tabStartY-tabShiftY;    tabShiftX = (lastLineDist-tabSize*2) * Math.cos(lastAngle);    tabShiftY = (lastLineDist-tabSize*2) * Math.sin(lastAngle);    drawLine(tabStartX,tabStartY,tabStartX-tabShiftX,tabStartY-tabShiftY,{"addTo":g,"strokeColor":black});    drawLine(tabStartX-tabShiftX,tabStartY-tabShiftY,currX+pw/2,currY+sh,{"addTo":g,"strokeColor":black});} // end createEqTri()function createTube(path) {    var pw,ph,curvew,totalw;    pw = path.width;    ph = path.height;    curvew = Math.PI*(path.width/2);//~     $.writeln("width: " + path.width);//~     $.writeln("height: " + path.height);//~     $.writeln(curvew);        //rectangle(top,left,width,height);    totalw = pw+curvew;    var rect = artLayer.pathItems.rectangle( currY, currX, totalw, ph);    rect.strokeColor = black;        currX += pw/2;    drawLine(currX,currY+9,currX,currY-ph-9,red);    currX += curvew;    drawLine(currX,currY+9,currX,currY-ph-9,red);        currX += 36;}function drawLine(x1,y1,x2,y2,opts) {//~     $.writeln(x1);//~     $.writeln(y1);//~     $.writeln(x2);//~     $.writeln(y2);    var newPath;    //create path object    if(opts["addTo"]){        newPath = opts["addTo"].pathItems.add();    } else {        newPath = doc.pathItems.add();    }        newPath.setEntirePath([[x1,y1],[x2,y2]]);        //styling options    if(opts["strokeColor"]) newPath.strokeColor = opts["strokeColor"];        return newPath;}function angleFromPoints(x1,y1,x2,y2) {    return Math.atan((y2-y1)/(x2-x1));}function dist(x1,y1,x2,y2) {    return Math.sqrt( ((x2-x1)*(x2-x1)) + ((y2-y1)*(y2-y1)) ); }