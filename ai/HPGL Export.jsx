/* WORK IN PROGRESS *//*Purpose: Converts an Adobe Illustrator Vector File to HPGL language*//*Settings*/var INCLUDELABEL = false, // will include the filename on your plot    fillType = 1, //1:     WILDSTYLE = true, //wildstyle will assign a random pen color to each shape    penOptions = 6; //total number of pens your plotter supports/* Don’t alter below this line! */var doc,shape,docH,pen,    hpglCom = "IN;", // buffer to stick output before writing to file    HPGLfile;    if (WILDSTYLE) {    var penStrings = new Array(penOptions);        //instantiate each array to skip those annoying `undefined`s    for(var s = 0; s < penStrings.length; s++) {        penStrings[s] = "";    }} else {    hpglCom += "SP1;";}if ( app.documents.length > 0 ) {    doc = app.activeDocument;    docH = Math.abs(doc.artboards[0].artboardRect[1] - doc.artboards[0].artboardRect[3]);    app.coordinateSystem = CoordinateSystem.ARTBOARDCOORDINATESYSTEM;    main();}function main() {    for (var i = doc.pathItems.length - 1; i >= 0; i--) {        shape = doc.pathItems[i];        if (shape.guides || shape.clipping) continue; // ignore clipping masks and guides        if (WILDSTYLE) pen = getRandomPen();                if(shape.closed) {            if (WILDSTYLE) {                penStrings[pen] += returnClosedPathHPGL(shape);            } else {                hpglCom += returnClosedPathHPGL(shape);            }        } else {            if (WILDSTYLE) {                penStrings[pen] += returnPathHPGL(shape);            } else {                hpglCom += returnPathHPGL(shape);            }        }    }    writeFile();}function writeFile() {    if(WILDSTYLE) {        for(var s = 0; s < penStrings.length; s++) {            if(penStrings[s].length > 0) {                hpglCom+="SP" + (s+1) + ";";                $.writeln("pen " + (s+1) + " content: " + penStrings[s]);                hpglCom += penStrings[s];            }        }    }    if(INCLUDELABEL) hpglCom += returnLabel();    hpglCom+="PU;" // include PU as last line to avoid pen bleed    var docFile = File(doc.fullName);    HPGLfile = (WILDSTYLE) ? File(docFile.path + "/" + docFile.displayName + "-wildstyle.hpgl") : File(docFile.path + "/" + docFile.displayName + ".hpgl");    HPGLfile.open("w");    HPGLfile.write( hpglCom );    HPGLfile.close();}/*  this needs work still */function returnLabel() {    var docFile = File(doc.fullName),        labelName = docFile.displayName.replace(".ai","");    // if your file name contains a $ its going to cause problems. sorry!    var temp = "DT$;\n";    temp += "PA0,10;SL;LB" + labelName + "$\n";    return temp;}function returnClosedPathHPGL(shape) {    var temp = "";    //~     var temp = "PU;";    if (isRect(shape)) {        var r1x = hpglUnit(shape.pathPoints[0].anchor[0]),            r1y = hpglUnit(shape.pathPoints[0].anchor[1] + docH),            r2x = hpglUnit(shape.pathPoints[2].anchor[0]),            r2y = hpglUnit(shape.pathPoints[2].anchor[1] + docH);         if (shape.filled && shape.fillColor.gray != 0) {            temp+= "FT1;";            temp += "PA" + r1x + "," + r1y + ";";            temp += "RA" + r2x + "," + r2y + ";";        }        if (shape.stroked) {            temp += "PA" + r1x + "," + r1y + ";";            temp += "EA" + r2x + "," + r2y + ";";        }    } else {        // TK    }    return temp;}function isRect(shape) {    /* wow this is a stupid amount of code...maybe not worth it? */    var is4 = (shape.pathPoints.length == 4);    if (!is4) {        $.writeln('not a retangle');        return false;    } else {        var a1 = calcAngle(shape.pathPoints[0].anchor, shape.pathPoints[1].anchor),            a2 = calcAngle(shape.pathPoints[1].anchor, shape.pathPoints[2].anchor),             a3 = calcAngle(shape.pathPoints[2].anchor, shape.pathPoints[3].anchor),             a4 = calcAngle(shape.pathPoints[3].anchor, shape.pathPoints[0].anchor);//~         $.writeln(a1);//~         $.writeln(a2);//~         $.writeln(a3);//~         $.writeln(a4);//~         $.writeln((a1 == 180 && a2 == 90 && a3 == 0 && a4 == -90) || //~         (a1 == 0 && a2 == -90 && a3 == 180 && a4 == 90) || (a1 == 0 && a2 == 90 && a3 == 180 && a4 == -90) ||//~         (a1 == 180 && a2 == -90 && a3 == 0 && a4 == 90) || (a1 == -90 && a2 == 180 && a3 == 90 && a4 == 0));        return ((a1 == 180 && a2 == 90 && a3 == 0 && a4 == -90) ||         (a1 == 0 && a2 == -90 && a3 == 180 && a4 == 90) || (a1 == 0 && a2 == 90 && a3 == 180 && a4 == -90) ||        (a1 == 180 && a2 == -90 && a3 == 0 && a4 == 90) || (a1 == -90 && a2 == 180 && a3 == 90 && a4 == 0) );    }    $.writeln('possible error');    return false;}function returnPathHPGL(shape) {    var temp = "PU";    for (var p= 0; p < shape.pathPoints.length; p++) {        if (p == 1) temp += "PD";        temp+= "";        temp+=  hpglUnit(shape.pathPoints[p].anchor[0]);          temp+= ",";        temp+= hpglUnit(shape.pathPoints[p].anchor[1] + docH );                if (p == 0) {            temp+= ";";        } else if( p!= shape.pathPoints.length-1) {            temp+= ",";        }    }        // if the shape is closed we need to pass it the last point again    if(shape.closed) {        temp+= ",";        temp+=  hpglUnit(shape.pathPoints[0].anchor[0]);          temp+= ",";        temp+= hpglUnit(shape.pathPoints[0].anchor[1] + docH );    }    temp += ";"    return temp;}function hpglUnit(ptUnit) {    return Math.abs(Math.round( (ptUnit.toFixed(2)/72)*1016 ));}/*  not necessary with `app.coordinateSystem = CoordinateSystem.ARTBOARDCOORDINATESYSTEM;` but will leave here  */function convertPoint(item) {        return doc.convertCoordinate(item,CoordinateSystem.DOCUMENTCOORDINATESYSTEM, CoordinateSystem.ARTBOARDCOORDINATESYSTEM);}function getRandomPenSP() {    var pen = Math.ceil(Math.random()*penOptions);    return "SP"+pen+";";}function getRandomPen() {    return Math.floor(Math.random()*penOptions);}function calcAngle (p1,p2) {    var angleDeg = Math.atan2(p2[1].toFixed(2) - p1[1].toFixed(2), p2[0].toFixed(2) - p1[0].toFixed(2)) * 180 / Math.PI;    return angleDeg;}