#target illustrator/* WORK IN PROGRESS *//*Purpose: Converts an Adobe Illustrator Vector File to HPGL language*//*Settings*/var COORDINATETYPE = "BOTTOMLEFT", // "BOTTOMLEFT" or  "CENTER"    INCLUDELABEL = false, // will include the filename on your plot    fillType = 1, //    checkColors = true,    WILDSTYLE = false, //wildstyle will assign a random pen color to each shape    penOptions = 4, //total number of pens your plotter supports    defaultFillType = "FT3,6,45",    defaultPT = 0.3;    checkForCircles = false;/* Don’t alter below this line! */var doc,shape,docH,yReset,xReset,pen,    hpglCom = "IN;", // buffer to stick output before writing to file    HPGLfile;    if (WILDSTYLE || checkColors) {    var penStrings = new Array(penOptions);        //instantiate each array to skip those annoying `undefined`s    for(var s = 0; s < penStrings.length; s++) {        penStrings[s] = "";    }} else {    hpglCom += "SP1;";}if ( app.documents.length > 0 ) {    doc = app.activeDocument;    docH = Math.abs(doc.artboards[0].artboardRect[1] - doc.artboards[0].artboardRect[3])        if(COORDINATETYPE == "BOTTOMLEFT") {        xReset = 0;        yReset = docH;        $.writeln(docH);    } else {        xReset = -1 * Math.abs( (doc.artboards[0].artboardRect[0] - doc.artboards[0].artboardRect[2])/2) ;        yReset = -1 * Math.abs( (doc.artboards[0].artboardRect[1] - doc.artboards[0].artboardRect[3])/2  ) + docH;    }        app.coordinateSystem = CoordinateSystem.ARTBOARDCOORDINATESYSTEM;    main();}function main() {    $.writeln('total paths:' + doc.pathItems.length);    for (var i = doc.pathItems.length - 1; i >= 0; i--) {        $.writeln('processing path:' + i);        shape = doc.pathItems[i];        if (shape.guides || shape.clipping) continue; // ignore clipping masks and guides        if (WILDSTYLE) pen = getRandomPen();                if(shape.closed) {            if (WILDSTYLE) {                penStrings[pen] += returnClosedPathHPGL(shape);            } else if(checkColors) {                var penNum = getPenNum(shape);                penStrings[penNum] += returnClosedPathHPGL(shape);            } else {                hpglCom += returnClosedPathHPGL(shape);            }        } else {            if (WILDSTYLE) {                penStrings[pen] += returnPathHPGL(shape);            } else if(checkColors) {                var penNum = getPenNum(shape);                penStrings[penNum] += returnClosedPathHPGL(shape);            } else {                hpglCom += returnPathHPGL(shape);            }        }    }    writeFile();}function writeFile() {    if(WILDSTYLE || checkColors) {        for(var s = 0; s < penStrings.length; s++) {            if(penStrings[s].length > 0) {                hpglCom+="SP" + (s+1) + ";";                hpglCom += penStrings[s];            }        }    }    if(INCLUDELABEL) hpglCom += returnLabel();    hpglCom+="PU;" // include PU as last line to avoid pen bleed    var docFile = File(doc.fullName);    HPGLfile = (WILDSTYLE) ? File(docFile.path + "/" + docFile.displayName + "-wildstyle.hpgl") : File(docFile.path + "/" + docFile.displayName + ".hpgl");    HPGLfile.open("w");    HPGLfile.write( hpglCom );    HPGLfile.close();}/*  this needs work still */function returnLabel() {    var docFile = File(doc.fullName),        labelName = docFile.displayName.replace(".ai","");    // if your file name contains a $ its going to cause problems. sorry!    var temp = "DT$;\n";    temp += "PA0,10;SL;LB" + labelName + "$\n";    return temp;}function returnClosedPathHPGL(shape) {    var temp = "";    //~     var temp = "PU;";    if (isRect(shape)) {        var r1x = hpglUnit(shape.pathPoints[0].anchor[0] + xReset),            r1y = hpglUnit(shape.pathPoints[0].anchor[1] + yReset),            r2x = hpglUnit(shape.pathPoints[2].anchor[0] + xReset),            r2y = hpglUnit(shape.pathPoints[2].anchor[1] + yReset);         if (shape.filled && shape.fillColor.gray != 0) {            if (WILDSTYLE) {                temp += getRandomFT();            } else {                temp += defaultFillType + ";";            }            temp += "PA" + r1x + "," + r1y + ";";            temp += "RA" + r2x + "," + r2y + ";";        }        if (shape.stroked && shape.strokeColor.gray != 0) {            temp += "PA" + r1x + "," + r1y + ";";            temp += "EA" + r2x + "," + r2y + ";";        }    } else if ( checkForCircles && isCircle(shape) ) {        var c1x = hpglUnit(shape.pathPoints[0].anchor[0] + xReset),            c1y = hpglUnit(shape.pathPoints[0].anchor[1] + yReset),            c2x = hpglUnit(shape.pathPoints[2].anchor[0] + xReset),            c2y = hpglUnit(shape.pathPoints[2].anchor[1] + yReset),            cx = (c1x+c2x)/2,            cy = (c1y+c2y)/2,            r = calcPathDist(cx, cy, c2x, c2y);                    if (shape.filled && shape.fillColor.gray != 0) {            if (WILDSTYLE) {                temp += getRandomFT();            } else {                temp += defaultFillType + ";";            }            temp += "PA" + cx + "," + cy +";"; //center point            temp += "WG" + r + ",0,360;"            temp += "PU;";        }        if (shape.stroked && shape.strokeColor.gray != 0) {            temp += "PA" + cx + "," + cy +";"; //center point            temp += "CI" + r +";"; // radius            temp += "PU;";        }            } else {        temp += returnPathHPGL(shape);    }    return temp;}function isCircle(shape) {    var is4 = (shape.pathPoints.length == 4);    if (!is4) {        return false;    } else {        var t1 = shape.pathPoints[0].pointType == PointType.SMOOTH,               t2 = shape.pathPoints[0].pointType == PointType.SMOOTH,               t3 = shape.pathPoints[0].pointType == PointType.SMOOTH,               t4 = shape.pathPoints[0].pointType == PointType.SMOOTH;          $.writeln('t1 is smooth: ' + t1)         return (t1 == t2 == t3 == t4 == true );    }    $.writeln('possible error');    return false;}function isRect(shape) {    /* wow this is a stupid amount of code...maybe not worth it? */    var is4 = (shape.pathPoints.length == 4);    if (!is4) {        return false;    } else if(shape.pathPoints[0].pointType == PointType.SMOOTH || shape.pathPoints[1].pointType == PointType.SMOOTH || shape.pathPoints[2].pointType == PointType.SMOOTH || shape.pathPoints[3].pointType == PointType.SMOOTH ){        return false;    } else {        var a1 = calcAngle(shape.pathPoints[0].anchor, shape.pathPoints[1].anchor),            a2 = calcAngle(shape.pathPoints[1].anchor, shape.pathPoints[2].anchor),             a3 = calcAngle(shape.pathPoints[2].anchor, shape.pathPoints[3].anchor),             a4 = calcAngle(shape.pathPoints[3].anchor, shape.pathPoints[0].anchor);//~         $.writeln(a2);//~         $.writeln(a3);//~         $.writeln(a4);//~         $.writeln((a1 == 180 && a2 == 90 && a3 == 0 && a4 == -90) || //~         (a1 == 0 && a2 == -90 && a3 == 180 && a4 == 90) || (a1 == 0 && a2 == 90 && a3 == 180 && a4 == -90) ||//~         (a1 == 180 && a2 == -90 && a3 == 0 && a4 == 90) || (a1 == -90 && a2 == 180 && a3 == 90 && a4 == 0));        return ((a1 == 180 && a2 == 90 && a3 == 0 && a4 == -90) ||         (a1 == 0 && a2 == -90 && a3 == 180 && a4 == 90) || (a1 == 0 && a2 == 90 && a3 == 180 && a4 == -90) ||        (a1 == 180 && a2 == -90 && a3 == 0 && a4 == 90) || (a1 == -90 && a2 == 180 && a3 == 90 && a4 == 0) );    }    $.writeln('possible error');    return false;}function returnPathHPGL(shape) {    var temp = "PU";    for (var p= 0; p < shape.pathPoints.length; p++) {        if (p == 1) temp += "PD";        temp+= "";        temp+=  hpglUnit(shape.pathPoints[p].anchor[0] + xReset);          temp+= ",";        temp+= hpglUnit(shape.pathPoints[p].anchor[1] + yReset);                if (p == 0) {            temp+= ";";        } else if( p!= shape.pathPoints.length-1) {            temp+= ",";        }    }        // if the shape is closed we need to pass it the last point again    if(shape.closed) {        temp+= ",";        temp+=  hpglUnit(shape.pathPoints[0].anchor[0] + xReset);          temp+= ",";        temp+= hpglUnit(shape.pathPoints[0].anchor[1] + yReset);    }    temp += ";"    temp += "PU;";    return temp;}function hpglUnit(ptUnit) {    return Math.round( (ptUnit.toFixed(2)/72)*1016 );}/*  not necessary with `app.coordinateSystem = CoordinateSystem.ARTBOARDCOORDINATESYSTEM;` but will leave here  */function convertPoint(item) {        return doc.convertCoordinate(item,CoordinateSystem.DOCUMENTCOORDINATESYSTEM, CoordinateSystem.ARTBOARDCOORDINATESYSTEM);}function getRandomPenSP() {    var pen = Math.ceil(Math.random()*penOptions);    return "SP"+pen+";";}function getRandomPen() {    return Math.floor(Math.random()*penOptions);}function getPenNum(shape) {//~     $.writeln(shape.strokeColor);//~     $.writeln('gray val ' + shape.strokeColor.black);//~ $.writeln('red val ' + shape.strokeColor.red);//~ $.writeln('blue val ' + shape.strokeColor.blue);//~ $.writeln('green val ' + shape.strokeColor.green);        if((shape.strokeColor.red == 0 && shape.strokeColor.blue == 0 && shape.strokeColor.green == 0) || (shape.strokeColor.red == 35 && shape.strokeColor.blue == 31 && shape.strokeColor.green == 32)) {        return 0;    } else if(shape.strokeColor.red == 255){        return 1;    } else if(shape.strokeColor.blue == 255){        return 2;    } else if(shape.strokeColor.green == 255){        return 3;    } else if(shape.strokeColor.blue == 255){        return 1;    } else {        return 0;    }    return 1;}function getRandomFT() {    var temp = "FT",        number = Math.ceil(Math.random()*4),        spacing, angle;    if (number < 2) {        spacing = Math.ceil(Math.random()*10);        angle = Math.round(Math.random()*90);        temp += (number + "," + spacing + "," + angle + ";");    } else {        temp += (number + ";");    }    return temp;}function calcAngle (p1,p2) {    var angleDeg = Math.atan2(p2[1].toFixed(2) - p1[1].toFixed(2), p2[0].toFixed(2) - p1[0].toFixed(2)) * 180 / Math.PI;    return angleDeg;}function calcPathDist (x1,y1,x2,y2) {    var dist = Math.sqrt( Math.pow ((x2 - x1), 2) + Math.pow ((y2 - y1), 2) );    return dist;}